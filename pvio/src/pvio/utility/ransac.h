/**************************************************************************
* This file is part of PVIO
*
* Copyright (c) ZJU-SenseTime Joint Lab of 3D Vision. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
**************************************************************************/
#ifndef PVIO_RANSAC_H
#define PVIO_RANSAC_H

#include <pvio/common.h>
#include <pvio/utility/random.h>

namespace pvio {

template <size_t ModelDoF, typename ModelType, typename ModelSolver, typename ModelEvaluator>
struct Ransac {
    double threshold;
    double confidence;
    size_t max_iteration;
    int seed;

    ModelType model;
    size_t inlier_count;
    std::vector<char> inlier_mask;

    Ransac(double threshold, double confidence = 0.999, size_t max_iteration = 1000, int seed = 0) :
        threshold(threshold), confidence(confidence), max_iteration(max_iteration), seed(seed) {
    }

    template <typename... DataTypes>
    ModelType solve(const std::vector<DataTypes> &... data) {
        std::tuple<const std::vector<DataTypes> &...> tdata = std::make_tuple(std::cref(data)...);
        size_t size = std::get<0>(tdata).size();

        LotBox lotbox(size);
        lotbox.seed(seed);

        double K = log(std::max(1 - confidence, 1.0e-5));

        inlier_count = 0;

        if (size < ModelDoF) {
            std::vector<char> _(size, 0);
            inlier_mask.swap(_);
            return model;
        }

        size_t iter_max = max_iteration;
        for (size_t iter = 0; iter < iter_max; ++iter) {
            std::tuple<std::array<DataTypes, ModelDoF>...> tsample;

            lotbox.refill_all();
            for (size_t si = 0; si < ModelDoF; ++si) {
                size_t sample_index = lotbox.draw_without_replacement();
                make_sample(tdata, tsample, sample_index, si);
            }

            std::vector<ModelType> models{apply(ModelSolver(), tsample)};
            for (const auto &current_model : models) {
                size_t current_inlier_count = 0;
                std::vector<char> current_inlier_mask(size, 0);
                ModelEvaluator eval(current_model);
                for (size_t i = 0; i < size; ++i) {
                    double error = eval(data[i]...);
                    if (error <= threshold) {
                        current_inlier_count++;
                        current_inlier_mask[i] = 1;
                    }
                }

                if (current_inlier_count > inlier_count) {
                    model = current_model;
                    inlier_count = current_inlier_count;
                    inlier_mask.swap(current_inlier_mask);

                    double inlier_ratio = inlier_count / (double)size;
                    double N = K / log(1 - pow(inlier_ratio, 5));
                    if (N < (double)iter_max) {
                        iter_max = (size_t)ceil(N);
                    }
                }
            }
        }

        return model;
    }

  private:
    template <class Data, class Sample, size_t... I>
    static void make_sample_impl(Data &&data, Sample &&sample, size_t idata, size_t isample, std::index_sequence<I...>) {
        [[maybe_unused]] auto ret = {(std::get<I>(sample)[isample] = std::get<I>(data)[idata])...};
    }

    template <class Data, class Sample>
    static void make_sample(Data &&data, Sample &&sample, size_t idata, size_t isample) {
        make_sample_impl(std::forward<Data>(data), std::forward<Sample>(sample), idata, isample,
                         std::make_index_sequence<std::tuple_size<typename std::remove_reference<Data>::type>::value>{});
    }
};

} // namespace pvio

#endif // PVIO_RANSAC_H
